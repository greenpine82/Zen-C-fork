
import "../../std/core.zc"
import "../../std/vec.zc"
import "../../std/string.zc"

struct Sha1Digest {
    bytes: u8[20];
}

struct Sha1 {
    state: u32[5];
    count: u64; // bit count
    buffer: u8[64];
}

impl Sha1 {
    fn new() -> Sha1 {
        let s: Sha1;
        s.state[0] = 0x67452301;
        s.state[1] = 0xEFCDAB89;
        s.state[2] = 0x98BADCFE;
        s.state[3] = 0x10325476;
        s.state[4] = 0xC3D2E1F0;
        
        s.count = 0;
        let buf_ptr = &s.buffer[0];
        raw { memset(buf_ptr, 0, 64); }
        return s;
    }

    fn _transform(self, data: u8*) {
        let a = self.state[0];
        let b = self.state[1];
        let c = self.state[2];
        let d = self.state[3];
        let e = self.state[4];
        
        let w: u32[80];
        
        // Prepare message schedule
        for (let i = 0; i < 16; i = i + 1) {
            let be_val: u32 = ((u32)data[i*4] << 24) | ((u32)data[i*4+1] << 16) | ((u32)data[i*4+2] << 8) | ((u32)data[i*4+3]);
            w[i] = be_val;
        }
        
        for (let i = 16; i < 80; i = i + 1) {
            let temp = w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16];
            // Rotate left 1
            w[i] = (temp << 1) | (temp >> 31);
        }
        
        for (let i = 0; i < 80; i = i + 1) {
            let f: u32;
            let k: u32;
            
            if (i < 20) {
                f = (b & c) | ((~b) & d);
                k = 0x5A827999;
            } else if (i < 40) {
                f = b ^ c ^ d;
                k = 0x6ED9EBA1;
            } else if (i < 60) {
                f = (b & c) | (b & d) | (c & d);
                k = 0x8F1BBCDC;
            } else {
                f = b ^ c ^ d;
                k = 0xCA62C1D6;
            }
            
            // Rotate a left 5
            let temp = ((a << 5) | (a >> 27)) + f + e + k + w[i];
            e = d;
            d = c;
            // Rotate b left 30
            c = (b << 30) | (b >> 2);
            b = a;
            a = temp;
        }
        
        self.state[0] = self.state[0] + a;
        self.state[1] = self.state[1] + b;
        self.state[2] = self.state[2] + c;
        self.state[3] = self.state[3] + d;
        self.state[4] = self.state[4] + e;
    }

    fn update(self, data: u8*, len: usize) {
        let i: usize = 0;
        let j: usize = (usize)((self.count >> 3) & 0x3F);
        
        self.count = self.count + (len << 3); // Add bits
        
        if ((j + len) > 63) {
            let dst = &self.buffer[j];
            let n1 = 64 - j;
            raw { memcpy(dst, data, n1); }
            
            self._transform(&self.buffer[0]);
            
            i = 64 - j;
            while ((i + 63) < len) {
                self._transform(&data[i]);
                 i = i + 64;
            }
            j = 0;
        } else {
             i = 0;
        }
        
        let dst2 = &self.buffer[j];
        let src2 = &data[i];
        let n2 = len - i;
        raw { memcpy(dst2, src2, n2); }
    }

    fn final(self) -> Sha1Digest {
         let count: u64 = self.count;
         // let i was unused
         
         let final_count: u8[8];
         for(let k=0; k<8; k=k+1) {
             final_count[k] = (u8)((count >> ((7-k)*8)) & 0xFF);
         }
         
         let c: u8 = 0x80;
         self.update(&c, 1);
         
         let zero: u8 = 0;
         while ((self.count & 504) != 448) { // 504 = 0x1F8 ?? No, wait. logic check.
             // Just pad with zeros until length % 64 == 56 bytes
             // The simplified update logic handles buffer filling.
             // Just call update with 0 until satisfies condition.
             // (count % 512) == 448 bits = 56 bytes
             // count is in bits. 
             // (count / 8) % 64 == 56
             self.update(&zero, 1);
         }
         
         // Append length (64 bits, big endian)
         // Actually the standard says append 0x80, then 0s, then 64-bit length.
         // My loop above pads 0s.
         // But I need to pass the raw bytes of length.
         // I can't call update because update modifies count!
         // Ah, classic mistake. 
         // I should manually patch buffer? 
         
         // RFC 3174 Method 1:
         // 1. Pad with '1' bit (0x80 byte) - Done above.
         // 2. Pad with '0' bits until length % 512 == 448
         // 3. Append 64-bit length.
         
         // My update logic handles the buffer filling and transform.
         // But update increments count.
         // The length to append is the ORIGINAL length.
         // So I saved `final_count` (bytes of original length) before padding.
         
         // But calls to update are modifying buffer.
         // I need to ensure the LAST block (56-64 bytes) is filled correctly.
         
         // Let's do explicit padding without update for the last part? 
         // Or just trick it. Pass data but don't increment count? No.
         
         // Correct Approach:
         // `final` should handle padding logic directly on buffer?
         
         // Let's rely on `update` for padding 0s, but use a dummy object or just correct logic?
         // NO. Standard implementations usually just manual fill buffer.
         
         // Simpler logic:
         // We already appended 0x80.
         // Now logic:
         // Pad with 0s until data size is congruent to 56 mod 64.
         // Then append 8 bytes of length.
         
         // zero already defined above
         while((self.count & 504) != 448) {
             self.update(&zero, 1);
         }
         // Note: `update` increases self.count. 
         // But we assume `final_count` holds the length BEFORE padding.
         // We need to write `final_count` into the stream.
         // But `update` will ADD 64 bits to count if we use it to write the length.
         // It doesn't matter, `count` is not used in hash computation (transform), only for padding alignment.
         // So calling update with length bytes is fine, as long as we put the RIGHT bytes.
         
         self.update(&final_count[0], 8);
         
         // Extract result
         let digest: Sha1Digest;
         for(let k=0; k<20; k=k+1) {
             let idx = k >> 2; // k / 4
             let offset = (3 - (k & 3)) * 8;
             digest.bytes[k] = (u8)((self.state[idx] >> offset) & 0xFF);
         }
         return digest;
    }
    
    // Convenience static method. simple implementation.
    fn hash(data: u8*, len: usize) -> Sha1Digest {
        let sha = Sha1::new();
        sha.update(data, len);
        return sha.final();
    }
}
